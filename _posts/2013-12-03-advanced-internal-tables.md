---
layout: post
title: Advanced Internal Tables
date: 2013-12-03 12:04
author: administrator
comments: true
categories: [ABAP]
---
<h1>Advanced Internal Tables, Part 1</h1><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#ChapterObjectives">Chapter Objectives</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#TestingandModifyingInternalTableContents">Testing and Modifying Internal Table Contents</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#ObtainingInformationaboutanInternalTable">Obtaining Information about an Internal Table</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#DeterminingWhetheranInternalTableIsEmpty">Determining Whether an Internal Table Is Empty</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#DeterminingtheNumberofRowsinanInternalTable">Determining the Number of Rows in an Internal Table</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SampleProgramthatObtainsInformationAboutanInternalTable">Sample Program that Obtains Information About an Internal Table</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#CopyingDatafromoneInternalTabletoAnother">Copying Data from one Internal Table to Another</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#CopyingaPortionofanInternalTable">Copying a Portion of an Internal Table</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SampleProgramthatCopiesDataBetweenInternalTables">Sample Program that Copies Data Between Internal Tables</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#ComparingtheContentsofTwoInternalTables">Comparing the Contents of Two Internal Tables</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#UsingtheeditorcallStatement">Using the editor-call Statement</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SyntaxfortheeditorcallStatement">Syntax for the editor-call Statement</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#InsertingRowsintoanInternalTable">Inserting Rows into an Internal Table</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SyntaxfortheinsertStatement">Syntax for the insert Statement</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#insertwaintoitindexn">insert [wa into] it [index n]</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#ModifyingRowsinanInternalTable">Modifying Rows in an Internal Table</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SyntaxforthemodifyStatement">Syntax for the modify Statement</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#DeletingInternalTableContents">Deleting Internal Table Contents</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#UsingfreetoDeleteInternalTableContents">Using free to Delete Internal Table Contents</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#UsingrefreshtoDeleteInternalTableContents">Using refresh to Delete Internal Table Contents</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#UsingclearwithanInternalTable">Using clear with an Internal Table</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#UsingthedeleteStatementtoDeleteRowsfromanInternalTable">Using the delete Statement to Delete Rows from an Internal Table</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#CreatingTopListsUsingappendsortedby">Creating Top 10 Lists Using append sorted by</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SyntaxfortheappendsortedbyStatement">Syntax for the append sorted by Statement</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#FillinganInternalTableUsingcollect">Filling an Internal Table Using collect</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#SyntaxforthecollectStatement">Syntax for the collect Statement</a></li><br/></ul><br/></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#Summary">Summary</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#QampA">Q&amp;A</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#Workshop">Workshop</a><br/><ul><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#Quiz">Quiz</a></li><br/>	<li><a href="http://www.sapnet.ru/abap21day/ch12/ch12.htm#Exercise">Exercise 1</a></li><br/></ul><br/></li><br/></ul><br/><br/><hr /><br/><br/><h2><a name="ChapterObjectives"></a><span style="color: #ff0000; font-size: x-large;">Chapter Objectives</span></h2><br/>After you complete this chapter, you should be able to:<br/><ul><br/>	<li>Recognize the table body operator and use it to test for the existence of data in an internal table, and to compare the contents of two internal tables for equality</li><br/>	<li>Determine the number of rows in an internal table using <tt>describe</tt> and <tt>sy-tfill</tt></li><br/>	<li>Copy the contents from one internal table to another using the table body operator and the <tt>append lines</tt> and <tt>insert lines</tt> statements</li><br/>	<li>View and modify internal tables using <tt>editor-call</tt></li><br/>	<li>Use the <tt>insert</tt> and <tt>modify</tt> statements to change the internal table contents</li><br/>	<li>Delete rows from an internal table using <tt>delete</tt>, <tt>delete ... where</tt>, <tt>clear</tt>, <tt>clear it[]</tt>, <tt>refresh</tt>, and <tt>free</tt></li><br/>	<li>Fill an internal table using <tt>append sorted by</tt> and <tt>collect</tt></li><br/></ul><br/><h2><a name="TestingandModifyingInternalTableContents"></a><span style="color: #ff0000; font-size: x-large;">Testing and Modifying Internal Table Contents</span></h2><br/>Use the following constructs to test and modify the contents of internal tables:<br/><ul><br/>	<li>The table body operator</li><br/>	<li><tt>describe table</tt></li><br/>	<li><tt>append lines</tt></li><br/>	<li><tt>insert lines</tt></li><br/>	<li><tt>editor-call</tt></li><br/>	<li><tt>insert</tt></li><br/>	<li><tt>modify</tt></li><br/>	<li><tt>free</tt></li><br/>	<li><tt>delete</tt></li><br/>	<li><tt>clear</tt></li><br/>	<li><tt>refresh</tt></li><br/>	<li>append sorted by</li><br/>	<li>collect</li><br/></ul><br/>The body of an internal table is represented by the syntax <tt><i>it</i>[]</tt>, where <tt><i>it</i></tt> is the name of any internal table. <tt>it[]</tt> means "the body of the internal table <tt>it</tt>." There cannot be anything between the square brackets; they must be written precisely as shown. You can use this syntax to perform efficient table operations that do not require the use of a header line. These operations are described throughout this chapter.<br/><br/>If an internal table does not have a header line, the internal table name itself represents the body. For example, if internal table <tt>it</tt> does not have a header line, you can use either <tt>it[]</tt> or <tt>it</tt> to represent the body; they are equivalent.<br/><h2><a name="ObtainingInformationaboutanInternalTable"></a><span style="color: #ff0000; font-size: x-large;">Obtaining Information about an Internal Table</span></h2><br/>You can obtain the following commonly needed information about an internal table:<br/><ul><br/>	<li>Whether the internal table contains data</li><br/>	<li>How many rows it contains</li><br/></ul><br/><h3><a name="DeterminingWhetheranInternalTableIsEmpty"></a>Determining Whether an Internal Table Is Empty</h3><br/>If the body of an internal table contains only initial values (blanks and spaces), it is empty. Therefore, to determine whether an internal table contains any rows, test the body with the following statement:<br/><blockquote><br/><pre>if it[] is initial.</pre><br/></blockquote><br/>If the test is true, the internal table is empty. When false, it contains at least one row.<br/><h3><a name="DeterminingtheNumberofRowsinanInternalTable"></a>Determining the Number of Rows in an Internal Table</h3><br/>To determine the number of rows in an internal table, use the <tt>sy-tfill</tt> variable. It is set by the <tt>describe table</tt> statement.<br/><h4>Syntax for the describe table Statement</h4><br/>The following is the syntax for the <tt>describe table</tt> statement.<br/><blockquote><br/><pre>describe table <i>it</i> [lines <i>i</i>] [occurs <i>j</i>].</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is the name of an internal table.</li><br/>	<li><tt><i>i</i></tt> and <tt><i>j</i></tt> are numeric variables.</li><br/></ul><br/>This statement fills the three system variables shown in Table 12.1.<br/><br/><center><b>Table 12.1  DESCRIBE TABLE Statement Fills These System Variables</b></center><br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="192"><center><b>Variable</b></center></td><br/><td width="288"><center><b>Value</b></center></td><br/></tr><br/><tr valign="top"><br/><td width="192"><tt>sy-tfill</tt></td><br/><td width="288">Number of rows</td><br/></tr><br/><tr valign="top"><br/><td width="192"><tt>sy-tleng</tt></td><br/><td width="288">Length of a row in bytes</td><br/></tr><br/><tr valign="top"><br/><td width="192"><tt>sy-toccu</tt></td><br/><td width="288">Current value of the <tt>occurs</tt> clause</td><br/></tr><br/></tbody><br/></table><br/>The following points apply:<br/><ul><br/>	<li>If the <tt>lines <i>i</i></tt> addition is specified, the number of rows is placed in both <tt>sy-tfill</tt> and <tt><i>i</i></tt>.</li><br/>	<li>If the <tt>occurs <i>j</i></tt> addition is specified, the size of the <tt>occurs</tt> clause is placed in both <tt>sy-toccu</tt> and <tt><i>j</i></tt>.</li><br/></ul><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>NOTE</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>There is only one instance where <tt>sy-toccu </tt>will differ from the <tt>occurs </tt>clause on the table definition. When <tt>sy-tleng * sy-toccu &gt; 8192</tt>, and after one row has been added to the internal table, <tt>sy-toccu </tt>will be zero. This indicates that memory is being allocated in 8KB chunks for this internal table.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h3><a name="SampleProgramthatObtainsInformationAboutanInternalTable"></a>Sample Program that Obtains Information About an Internal Table</h3><br/>Listing 12.1 shows a sample program that obtains information about an internal table.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.1  The describe table Statement Uses System Variables to Quantify Table Contents<br/></b><br/><blockquote><br/><pre> 1  report ztx1201.<br/> 2  data: begin of it occurs 3,<br/> 3            f1 value 'X',<br/> 4            end of it,<br/> 5        n type i.<br/> 6 <br/> 7  if it[] is initial.<br/> 8      write: / 'it is empty'.<br/> 9      endif.<br/>10<br/>11 append: it, it, it.     "same as writing 'append it' 3 times.<br/>12<br/>13 if not it[] is initial.<br/>14     write: / 'it is not empty'.<br/>15     endif.<br/>16<br/>17 write: / 'number of  rows from sy-tabix:', sy-tabix.<br/>18 describe table it lines n.<br/>19 write: / 'number of  rows from sy-tfill:', sy-tfill,<br/>20        / 'length of a row from sy-tleng:', sy-tleng,<br/>21        / 'occurs value    from sy-toccu:', sy-toccu.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.1 produces this output:<br/><blockquote><br/><pre>it is empty                              <br/>it is not empty                          <br/>number of  rows from sy-tabix:          3<br/>number of  rows from sy-tfill:          3<br/>length of a row from sy-tleng:     1     <br/>occurs value    from sy-toccu:          3</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Line 7 compares the body of the internal table using the table body operator with initial values. The internal table does not yet contain any rows, so the test is true.</li><br/>	<li>Line 11 uses the chain operator (<tt>:</tt>) to append three identical rows to <tt>it</tt>.</li><br/>	<li>Line 13 tests the body again. This time, the test is preceded by a logical <tt>not.</tt> The internal table contains data, so this test is true.</li><br/>	<li>After each <tt>append</tt> statement, the value of <tt>sy-tabix</tt> is set to the number of rows in the internal table. Line 17 writes out its value.</li><br/>	<li>Line 18 uses the <tt>describe</tt> statement to obtain the number of rows and places it in <tt>sy-tfill</tt>. It also obtains the row length and size of the <tt>occurs</tt> clause and places them into <tt>sy-tleng</tt> and <tt>sy-toccu</tt>.</li><br/></ul><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>If you only need to know whether the table contains data and not how many rows it has, use the table body operator. It is more efficient than the <tt>describe table </tt>statement.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h2><a name="CopyingDatafromoneInternalTabletoAnother"></a><span style="color: #ff0000; font-size: x-large;">Copying Data from one Internal Table to Another</span></h2><br/>If two internal tables have the same structure, use the following statement to duplicate the contents of one internal table in another:<br/><blockquote><br/><pre>it2[] = it1[].</pre><br/></blockquote><br/>The preceding statement copies the contents of the body of <tt>it1</tt> and places it in the body of <tt>it2</tt>. Any existing contents in <tt>it2</tt> are overwritten. The contents of the header lines, if either internal table has one, remain unchanged. This is the most efficient way to copy the contents from one internal table to another.<br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>NOTE</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>Two internal tables have the same structure if 1) they both have the same number of components, and 2) the data type and length of each component is the same as the corresponding component of the other internal table. Only the component names do not have to match.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h3><a name="CopyingaPortionofanInternalTable"></a>Copying a Portion of an Internal Table</h3><br/>If you want to copy a portion of an internal table to another, or if you want to leave the contents of the target table in place, use the <tt>append lines</tt> and <tt>insert lines</tt> statements.<br/><h4>Using the append lines Statement</h4><br/>Use the <tt>append lines</tt> statement when you want to append rows to the end of the target table.<br/><h5>Syntax for the append lines Statement</h5><br/><blockquote>The following is the syntax for the <tt>append lines</tt> statement.</blockquote><br/><blockquote><br/><pre>append lines of <i>it1</i> [from <i>nf</i>] [to <i>nt</i>] to <i>it2</i>.</pre><br/></blockquote><br/><blockquote>where:<br/><ul><br/>	<li><tt><i>it1</i></tt> and <tt><i>it2</i></tt> are internal tables with or without header lines.</li><br/>	<li><tt><i>nf</i></tt> and <tt><i>nt</i></tt> are numeric variables, literals, or constants.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>The structures of <tt><i>it1</i></tt> and <tt><i>it2</i></tt> must match.</li><br/>	<li><tt>nf</tt> is the index of the first row to be copied from <tt>it1</tt>. If the <tt>from</tt> addition is not specified, copying begins from the first row of <tt>it1</tt>.</li><br/>	<li><tt>nt</tt> is the index of the last row to be copied from <tt>it1</tt>. If the <tt>to</tt> addition is not specified, copying continues to the last row of <tt>it1</tt>.</li><br/>	<li>If neither <tt>from</tt> nor <tt>to</tt> are specified, the entire table is appended.</li><br/>	<li>After the <tt>append lines</tt> statement has executed, <tt>sy-tabix</tt> contains the number of rows in the table.</li><br/></ul><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>Using <tt>append</tt> lines is three to four times faster than using <tt>append</tt> to add the rows one at a time.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;</blockquote><br/><h4>Using the insert lines Statement</h4><br/>Use the <tt>insert lines</tt> statement when you want to insert rows at a place other than the end into the target table.<br/><h5>Syntax for the insert lines Statement</h5><br/><blockquote>The following is the syntax for the <tt>insert lines</tt> statement.</blockquote><br/><blockquote><br/><pre>insert lines of <i>it1</i> [from <i>nf</i>] [to <i>nt</i>] into <i>it2</i> [index <i>nb</i>].</pre><br/></blockquote><br/><blockquote>where:<br/><ul><br/>	<li><tt><i>it1</i></tt> and <tt><i>it2</i></tt> are internal tables with or without header lines.</li><br/>	<li><tt><i>nf</i></tt>, <tt><i>nt</i></tt>, and <tt><i>nb</i></tt> are numeric variables, literals, or constants.</li><br/></ul><br/>All of the points that apply to the <tt>append lines</tt> statement also apply here. The difference is that rows from <tt><i>it1</i></tt> are inserted into <tt><i>it2</i></tt> before row number <tt><i>nb</i></tt>. If the value of <tt><i>nb</i></tt> is the number of rows in <tt><i>it2</i></tt> plus 1, the row is appended to the end of <tt><i>it2</i></tt>. If <tt><i>nb</i></tt> is greater than that, the row is not appended and <tt>sy-subrc</tt> is set to <tt>4</tt>. If <tt><i>nb</i></tt> is less than 1, a runtime error occurs.</blockquote><br/><blockquote>You can use this statement inside or outside of <tt>loop at <i>it2</i></tt>. If used outside, you must specify the <tt>index</tt> addition. Inside, <tt>index</tt> is optional. If it is not specified, the current row number in <tt><i>it2</i></tt> is assumed.</blockquote><br/><h3><a name="SampleProgramthatCopiesDataBetweenInternalTables"></a>Sample Program that Copies Data Between Internal Tables</h3><br/>Listing 12.2 shows a sample program that copies data from one internal table to another.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.2  This Program Copies the Data from One Internal Table to Another Using the append lines and insert lines Statements<br/></b><br/><blockquote><br/><pre> 1  report ztx1202.<br/> 2  data: begin of it1 occurs 10,<br/> 3            f1,<br/> 4            end of it1,<br/> 5        it2 like it1 occurs 10 with header line,<br/> 6        alpha(10) value 'ABCDEFGHIJ'.<br/> 7 <br/> 8  do 10 times varying it1-f1 from alpha+0 next alpha+1.<br/> 9      append it1.<br/>10     enddo.<br/>11<br/>12 append lines of it1 from 2 to 5 to it2.<br/>13 loop at it2.<br/>14     write it2-f1.<br/>15     endloop.<br/>16<br/>17 insert lines of it1 from 8 into it2 index 2.<br/>18 skip.<br/>19 loop at it2.<br/>20     write it2-f1.<br/>21     endloop.<br/>22<br/>23 loop at it2.<br/>24     if it2-f1 &gt;= 'E'.<br/>25         insert lines of it1 to 1 into it2.<br/>26         endif.<br/>27     endloop.<br/>28<br/>29 skip.<br/>30 loop at it2.<br/>31     write it2-f1.<br/>32     endloop.<br/>33<br/>34 skip.<br/>35 it2[] = it1[].<br/>36 loop at it2.<br/>37     write it2-f1.<br/>38     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.2 produces this output:<br/><blockquote><br/><pre>B C D E              <br/><br/>B H I J C D E        <br/><br/>B A H A I A J C D A E<br/><br/>A B C D E F G H I J</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 8 through 10 fill <tt>it1</tt> with 10 rows containing the first 10 letters of the alphabet.</li><br/>	<li>Line 12 appends rows 2 through 5 of <tt>it1</tt> to <tt>it2</tt>. <tt>it2</tt> now has four rows containing the letters <tt>B</tt> through <tt>E</tt>.</li><br/>	<li>On line 17, the <tt>to</tt> addition is not specified, so the end of <tt>it1</tt> is assumed. This inserts rows 8, 9, and 10 from <tt>it1</tt> into <tt>it2</tt> before row 2.</li><br/>	<li>On line 24, if the letter in <tt>it2-f1</tt> is greater than or equal to <tt>E</tt>, row 1 of <tt>it1</tt> is inserted before the current row of <tt>it2</tt>. (The <tt>from</tt> addition is not specified, so the beginning of <tt>it1</tt> is assumed.) This results in four rows being inserted. In the output, they are the <tt>'A'</tt> values.</li><br/>	<li>Line 35 copies the contents of <tt>it1</tt> to <tt>it2</tt>, completely overlaying the existing contents.</li><br/></ul><br/><h3><a name="ComparingtheContentsofTwoInternalTables"></a>Comparing the Contents of Two Internal Tables</h3><br/>You can use the table body operator to compare the contents of two internal tables, as shown here:<br/><blockquote><br/><pre>if it1[] = it2[].</pre><br/></blockquote><br/>To use this construct, the internal tables must have the same structure. If they do not, you will have to compare them manually, row by row.<br/><br/>This statement is true when <tt>it1</tt> and <tt>it2</tt> contain the same number of rows and the contents of each row are the same.<br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>The If - Equal to statement is the most efficient way to compare the con-tents of two internal tables.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h2><a name="UsingtheeditorcallStatement"></a><span style="color: #ff0000; font-size: x-large;">Using the editor-call Statement</span></h2><br/>The <tt>editor-call</tt> statement displays the contents of an internal table to the user in an editor similar to the ABAP/4 source code editor. It is useful for debugging and as a simple interface for allowing the user to enter and modify data in tabular form.<br/><h3><a name="SyntaxfortheeditorcallStatement"></a>Syntax for the editor-call Statement</h3><br/>The following is the syntax for the <tt>editor-call</tt> statement.<br/><blockquote><br/><pre>editor-call for <i>it</i> [title <i>t</i>] [display mode]</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is the name of an internal table.</li><br/>	<li><tt><i>t</i></tt> is a literal, constant, or variable.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li><tt><i>it</i></tt> can only contain type <tt>c</tt> components.</li><br/>	<li>The maximum length for a row is 72 characters.</li><br/>	<li><tt>t</tt> is the text displayed in the title bar of the editor window.</li><br/></ul><br/>The <tt>display mode</tt> addition causes the data to be displayed in the editor in display mode. The user will be able to search and scroll, but will not be able to change the contents.<br/><br/>After viewing or modifying the internal table contents via the editor, the user presses one of these buttons: Save, Back, Exit, or Cancel. Save saves the changes made to the internal table contents and returns to the program. Back, Exit, and Cancel leave the editor and return to the program. If changes have been made, the user is prompted to save or cancel the changes.<br/><br/>After the <tt>editor-call</tt> statement has executed, <tt>sy-subrc</tt> is set to the values shown in Table 12.2.<br/><br/><center><b>Table 12.2  Values of </b><tt><b>SY-SUBRC</b></tt><b> After the </b><tt><b>EDITOR-CALL</b></tt><b> Statement</b></center><br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="96"><center><b>sy-subrc</b></center></td><br/><td width="384"><center><b>Meaning</b></center></td><br/></tr><br/><tr valign="top"><br/><td width="96"><center><tt>0</tt></center></td><br/><td width="384">A save was performed. The contents of the internal table might or might not be changed.</td><br/></tr><br/><tr valign="top"><br/><td width="96"><center><tt>4</tt></center></td><br/><td width="384">The user did not perform a save. The contents of the internal table are unchanged.</td><br/></tr><br/></tbody><br/></table><br/>Listing 12.3 shows a sample program that uses the <tt>editor-call</tt> statement. In this example, the internal table is filled with five lines and displayed in the editor so that the user can modify the data. The contents are then written out, and a message is also written to indicate whether a change was performed.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.3  Use the editor-call Statement to View, Edit, and Debug the Contents of an Internal Table.<br/></b><br/><blockquote><br/><pre> 1  report ztx1203.<br/> 2  data: begin of it occurs 10,<br/> 3            t(72),                  "text<br/> 4            end of it,<br/> 5        save_it like it occurs 10.  "will contain copy of the original<br/> 6 <br/> 7  it-t = 'Name         :'. append it.<br/> 8  it-t = 'Address      :'. append it.<br/> 9  it-t = 'Phone        :'. append it.<br/>10 it-t = 'Freeform Text '. append it.<br/>11 clear it-t with '-'.     append it.<br/>12<br/>13 save_it = it[].                   "same as: save_it[] = it[].<br/>14 editor-call for it title 'Freeform Entry'.<br/>15 if sy-subrc = 4.                  "user did not perform a save<br/>16     write: / 'Data was not changed'.<br/>17 elseif save_it[] &lt;&gt; it[].         "user performed a save<br/>18     write: / 'Data was changed'.<br/>19 else.<br/>20     write: / 'Data was not changed'.<br/>21     endif.<br/>22 write: / sy-uline(72).<br/>23 loop at it.<br/>24     write: / it-t.<br/>25     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>If no data is entered when the editor is displayed, the code in Listing 12.3 produces this output:<br/><blockquote><br/><pre>Data was not changed                                       <br/>-----------------------------------------------------------------------<br/>Name         :                                                         <br/>Address      :                                                         <br/>Phone        :                                                         <br/>Freeform Text                                                          <br/>-------------------------------------------------------------------</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 2 through 4 define an internal table having a single component <tt>t</tt>, character length <tt>72</tt>.</li><br/>	<li>Line 5 defines a second internal table like the first. It will be used to hold a reference copy of the data in <tt>it</tt>. It does not have a header line. The header line has been left off because it is not needed in this program.</li><br/>	<li>Lines 7 through 11 append five lines to the internal table from the header line.</li><br/>	<li>Line 13 copies the body of <tt>it</tt> to the body of <tt>save_it</tt>. Because <tt>save_it</tt> does not have a header line, the left side of the assignment can be written with or without square brackets.</li><br/>	<li>Line 14 displays the contents of the internal table in the editor with the title <tt>Freeform Entry</tt>.</li><br/>	<li>Line 15 checks the value of <tt>sy-subrc</tt> to determine whether the user performed a save. If he did not, it is not possible that data was changed and a message is written out.</li><br/>	<li>Line 17 compares the new contents of <tt>it</tt> with the reference copy in <tt>save_it</tt>. If they are different, a message is written out. If they are the same, line 20 writes out a message to indicate this.</li><br/>	<li>Lines 22 writes out an underline 72 characters long.</li><br/>	<li>Lines 23 through 25 write out the new contents of the internal table, including any user modifications.</li><br/></ul><br/><h2><a name="InsertingRowsintoanInternalTable"></a><span style="color: #ff0000; font-size: x-large;">Inserting Rows into an Internal Table</span></h2><br/>To insert a single row into an internal table, use the <tt>insert</tt> statement.<br/><h3><a name="SyntaxfortheinsertStatement"></a>Syntax for the insert Statement</h3><br/>The following is the syntax for the <tt>insert</tt> statement.<br/><h3><a name="insertwaintoitindexn"></a>insert [wa into] it [index n]</h3><br/>where:<br/><ul><br/>	<li><tt><i>wa</i></tt> is a work area with the same structure as a row of internal table <tt><i>it</i></tt>.</li><br/>	<li><tt><i>n</i></tt> is a numeric literal, variable, or constant.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>If <tt><i>wa</i></tt> is specified, the contents of <tt><i>wa</i></tt> are inserted into <tt><i>it</i></tt>. <tt><i>wa</i></tt> must have the same structure as <tt><i>it</i></tt>.</li><br/>	<li>If <tt>wa</tt> is not specified, the contents of the header line are inserted into <tt>it</tt>. If <tt>it</tt> does not have a header line, <tt>wa</tt> must be specified.</li><br/>	<li>If <tt>index</tt> is specified, the new row is inserted before row <tt>n</tt>. Row <tt>n</tt> then becomes row <tt>n</tt>+1.</li><br/>	<li>The <tt>insert</tt> statement can be used inside or outside of <tt>loop at it</tt>. If it is outside, the <tt>index</tt> addition must be specified. If it is inside, <tt>index</tt> is optional. If it is not specified, the current row is assumed.</li><br/></ul><br/>Listing 12.4 contains a sample program that uses the <tt>insert</tt> statement.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.4  Use the insert Statement to Insert a Single Row into an Internal Table<br/></b><br/><blockquote><br/><pre> 1  report ztx1204.<br/> 2  data: begin of it occurs 5,<br/> 3            f1 like sy-index,<br/> 4            end of it.<br/> 5 <br/> 6  do 5 times.<br/> 7      it-f1 = sy-index.<br/> 8      append it.<br/> 9      enddo.<br/>10<br/>11 it-f1 = -99.<br/>12 insert it index 3.<br/>13<br/>14 loop at it.<br/>15     write / it-f1.<br/>16     endloop.<br/>17<br/>18 loop at it where f1 &gt;= 4.<br/>19     it-f1 = -88.<br/>20     insert it.<br/>21     endloop.<br/>22<br/>23 skip.<br/>24 loop at it.<br/>25     write / it-f1.<br/>26     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.4 produces this output:<br/><blockquote><br/><pre>         1     <br/>         2     <br/>        99-    <br/>         3     <br/>         4     <br/>         5     <br/><br/>         1     <br/>         2     <br/>        99-    <br/>         3     <br/>        88-    <br/>         4     <br/>        88-    <br/>         5</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 6 through 9 append five rows containing the numbers 1 through 5 to <tt>it</tt>.</li><br/>	<li>Line 11 assigns to the header line component <tt>it-f1</tt> a value of <tt>-99</tt>.</li><br/>	<li>Line 12 inserts the header line of <tt>it</tt> as new row into the body of <tt>it</tt> before row 3. The existing row 3 becomes row 4 after the insert.</li><br/>	<li>Line 18 retrieves those rows from the internal table that have an <tt>f1</tt> value greater than or equal to 4. Before each row, line 20 inserts a new row from the header line of <tt>it</tt>. Prior to the insert, line 19 changed the <tt>f1</tt> component to contain <tt>-88</tt>.</li><br/></ul><br/><b><span style="font-family: Frutiger-Black; color: #ffffff; font-size: x-large;">12</span></b><br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>After each <tt>insert </tt>statement is executed, the system re-indexes all rows below the one inserted. This introduces overhead when you insert rows near the top of a large internal table. If you need to insert a block of rows into a large internal table, prepare another table with the rows to be inserted and use <tt>insert lines </tt>instead. The rows in the target table will only be re-indexed once, after this statement has executed.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>When inserting a new row into <tt>it</tt> inside of a <tt>loop at it</tt>, the insert does not affect the internal table immediately, but instead it becomes effective on the next loop pass. When inserting a row <i>after</i> the current row, the table is re-indexed at the <tt>endloop</tt>, <tt>sy-tabix</tt> is incremented, and the next loop pass processes the row pointed to by <tt>sy-tabix</tt>. For example, suppose you are in the third loop pass and you insert a record before row 4. When <tt>endloop</tt> is executed, the new row becomes row 4, the old row 4 becomes row 5, and so on. <tt>Sy-tabix</tt> is incremented by 1, and the next loop pass processes the newly inserted record.<br/><br/>If, inside of a loop, you insert a row <i>before</i> the current row, the table is again re-indexed at the <tt>endloop</tt>. This time, however, <tt>sy-tabix</tt> is incremented by 1 plus the number of rows inserted before the current row. The next time through the loop, the row following the current row is processed. Suppose, for example, in the third loop pass you insert a row before row 3. At the <tt>endloop</tt>, the new row becomes row 3, row 3 becomes row 4, and so on. The row you just processed now has an index of 4. <tt>sy-tabix</tt> is incremented by 2, which gives 5. Row 4 was re-indexed to 5, so it is processed on the next loop pass.<br/><h2><a name="ModifyingRowsinanInternalTable"></a><span style="color: #ff0000; font-size: x-large;">Modifying Rows in an Internal Table</span></h2><br/>To modify the contents of one or more rows of an internal table, use the <tt>modify</tt> statement.<br/><h3><a name="SyntaxforthemodifyStatement"></a>Syntax for the modify Statement</h3><br/>The following is the syntax for the <tt>modify</tt> statement.<br/><blockquote><br/><pre>modify <i>it</i> [from <i>wa</i>] [index <i>n</i>] [transporting <i>c1</i> <i>c2</i> ... [where <i>exp</i>]]</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is the name of an internal table with or without a header line.</li><br/>	<li><tt><i>wa</i></tt> is a work area with the same structure as a row in the body of <tt><i>it</i></tt><i>.</i></li><br/>	<li><tt><i>n</i></tt> is a numeric literal, variable, or constant.</li><br/>	<li><tt><i>c1</i></tt> and <tt><i>c2</i></tt> are components of <tt><i>it</i></tt><i>.</i></li><br/>	<li><tt><i>exp</i></tt> is a logical expression involving components of <tt><i>it</i></tt><i>.</i></li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>If <tt>from <i>wa</i></tt> is specified, the row is overwritten with the contents of <tt><i>wa</i></tt>.</li><br/>	<li>If <tt>from wa</tt> is not specified, the row is overwritten with the contents of the header line.</li><br/>	<li>If <tt>index n</tt> is specified, <tt>n</tt> identifies the number of the row that is overwritten.</li><br/>	<li><tt>modify it</tt> can be specified inside or outside of <tt>loop at it</tt>. If it is outside, <tt>index <i>n</i></tt> must be specified. When inside, <tt>index <i>n</i></tt> is optional. If it is not specified, the current row is modified.</li><br/></ul><br/><tt>transporting</tt> specifies which components are to be overwritten. Without it, all are overwritten. With it, only the specified components are overwritten. The rest remain unchanged.<br/><br/>Specifying a <tt>where</tt> condition after <tt>transporting</tt> causes the specified components to be overwritten in all rows that satisfy the <tt>where</tt> clause. The left-hand side of each part of <tt><i>exp</i></tt> must specify a component of <tt><i>it</i></tt>. The same component can be specified both after <tt>transporting</tt> and in <tt><i>exp</i></tt>.<br/><br/>You can't use <tt>modify it</tt> with <tt>where</tt>:<br/><ul><br/>	<li>Inside of <tt>loop at it</tt></li><br/>	<li>With the <tt>index</tt> addition</li><br/></ul><br/>Listing 12.5 shows a sample program that modifies the contents of an internal table.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.5  Use modify to Overwrite the Existing Contents of One or More Rows of an Internal Table<br/></b><br/><blockquote><br/><pre> 1  report ztx1205.<br/> 2  data: begin of it occurs 5,<br/> 3            f1 like sy-index,<br/> 4            f2,<br/> 5            end of it,<br/> 6        alpha(5) value 'ABCDE'.<br/> 7 <br/> 8  do 5 times varying it-f2 from alpha+0 next alpha+1.<br/> 9      it-f1 = sy-index.<br/>10     append it.<br/>11     enddo.<br/>12<br/>13 it-f2 = 'Z'.<br/>14 modify it index 4.<br/>15<br/>16 loop at it.<br/>17     write: / it-f1, it-f2.<br/>18     endloop.<br/>19<br/>20 loop at it.<br/>21     it-f1 = it-f1 * 2.<br/>22     modify it.<br/>23     endloop.<br/>24<br/>25 skip.<br/>26 loop at it.<br/>27     write: / it-f1, it-f2.<br/>28     endloop.<br/>29<br/>30 it-f2 = 'X'.<br/>31 modify it transporting f2 where f1 &lt;&gt; 10.<br/>32<br/>33 skip.<br/>34 loop at it.<br/>35     write: / it-f1, it-f2.<br/>36     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.5 produces this output:<br/><blockquote><br/><pre>         1  A  <br/>         2  B  <br/>         3  C  <br/>         5  Z  <br/>         5  E  <br/><br/>         2  A  <br/>         4  B  <br/>         6  C  <br/>        10  Z  <br/>        10  E  <br/><br/>         2  X  <br/>         4  X  <br/>         6  X  <br/>        10  Z  <br/>        10  E</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 8 through 11 add five rows to <tt>it</tt>. Each row contains a sequential number and letter of the alphabet.</li><br/>	<li>Line 13 modifies the contents of <tt>it-f2</tt>, giving it a value of <tt>'Z'</tt>. <tt>it-f1</tt> is not modified, so it still contains the last value added to the table: <tt>5</tt>.</li><br/>	<li>Line 14 overwrites row 4 with the contents of the header line, changing <tt>f1</tt> to <tt>5</tt> and <tt>f2</tt> to <tt>Z</tt>.</li><br/>	<li>Lines 20 through 23 loop through all rows of <tt>it</tt>, placing each row one at a time into the header line. Line 21 multiplies by 2 the contents of header line component <tt>f1</tt>. Line 22 copies the contents of the header line back into the current row in the body of <tt>it</tt>, overwriting it.</li><br/>	<li>Line 30 modifies the contents of the header line component <tt>f2</tt>, assigning it a value of '<tt>X</tt>'.</li><br/>	<li>Line 31 modifies all rows in the body where <tt>f1</tt> is not equal to 10. Only the value of <tt>f2</tt> is copied from the header line and overwrites the <tt>f2</tt> values in the body. <tt>f1</tt> remains unchanged in the body and in the header line.</li><br/></ul><br/><h2><a name="DeletingInternalTableContents"></a><span style="color: #ff0000; font-size: x-large;">Deleting Internal Table Contents</span></h2><br/>To delete contents of an internal table, you can use the following statements:<br/><ul><br/>	<li><tt>free</tt></li><br/>	<li><tt>refresh</tt></li><br/>	<li><tt>clear</tt></li><br/>	<li><tt>delete</tt></li><br/></ul><br/><h3><a name="UsingfreetoDeleteInternalTableContents"></a>Using free to Delete Internal Table Contents</h3><br/>Use the <tt>free</tt> statement to delete all rows from an internal table and free the associated memory.<br/><h4>Syntax for the free Statement</h4><br/>The following is the syntax for the <tt>free</tt> statement.<br/><blockquote><br/><pre>free it.</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is an internal table with or without a header line.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>All rows are deleted and all memory used by the body of the internal table is freed.</li><br/>	<li>The header line, if it exists, remains unchanged.</li><br/></ul><br/>Use <tt>free</tt> when you are finished using an internal table.<br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>Although the memory for internal tables is automatically freed when your program ends, freeing it yourself is usually more efficient. The reason for this lies in the fact that when the output is displayed to the user, technically your program has not yet ended. All resources remain allocated and the pro-gram does not end until the user presses the Back button. This finally ends your program and frees all internal table contents. You can free the internal tables sooner by putting <tt>free </tt>statements at the end of your program. The internal table contents will be released before the user sees the list instead of after.</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>Listing 12.6 shows how to use the <tt>free</tt> statement.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.6  Use the free Statement to Delete All Rows from an Internal Table and Free the Associated Memory<br/></b><br/><blockquote><br/><pre>1  report ztx1206.<br/>2  data: begin of it occurs 3,<br/>3            f1 like sy-index,<br/>4            end of it.<br/>5 <br/>6  do 3 times.<br/>7      it-f1 = sy-index.<br/>8      append it.<br/> 9      enddo.<br/>10<br/>11 loop at it.<br/>12     write it-f1.<br/>13     endloop.<br/>14<br/>15 free it.<br/>16 if it[] is initial.<br/>17     write: / 'no rows exist in it after free'.<br/>18     endif.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.6 produces this output:<br/><blockquote><br/><pre>         1           2           3  <br/>no rows exist in it after free</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><br/>Line 15 deletes all rows from the internal table and frees the associated memory.<br/><h3><a name="UsingrefreshtoDeleteInternalTableContents"></a>Using refresh to Delete Internal Table Contents</h3><br/>Use the <tt>refresh</tt> statement to delete all rows from an internal table but leave the memory allocated.<br/><h4>Syntax for the refresh Statement</h4><br/>The following is the syntax for the <tt>refresh</tt> statement.<br/><blockquote><br/><pre>refresh it.</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is an internal table with or without a header line.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>All rows are deleted. All memory used by the body of the internal table remains allocated.</li><br/>	<li>The header line, if it exists, is unchanged.</li><br/></ul><br/>Use <tt>refresh</tt> when you want to delete all rows but you intend to fill the internal table back up again. For example, if you are producing a sales report by department, you might fill the internal table with all sales for one department, process the data, and write it out. Then, after a <tt>refresh</tt>, you could fill the internal table with the data for the next department, write it out, and so on.<br/><br/>If you intend to refill a table immediately after clearing it, <tt>refresh</tt> is more efficient than <tt>free</tt> because it avoids unnecessary memory allocations.<br/><br/>Listing 12.7 shows how to use the <tt>refresh</tt> statement.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.7  Use the refresh Statement to Delete All Rows from an Internal Table<br/></b><br/><blockquote><br/><pre> 1  report ztx1207.<br/> 2  data: begin of it occurs 3,<br/> 3            f1 like sy-index,<br/> 4            end of it,<br/> 5        i like sy-index.<br/> 6<br/> 7  do 3 times.<br/> 8      i = sy-index.<br/> 9      do 3 times.<br/>10         it-f1 = i * sy-index.<br/>11         append it.<br/>12         enddo.<br/>13     write: / ''.<br/>14     loop at it.<br/>15         write it-f1.<br/>16         endloop.<br/>17     refresh it.<br/>18     enddo.<br/>19<br/>20 free it.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.7 produces this output:<br/><blockquote><br/><pre>           1           2           3<br/>           2           4           6<br/>           3           6           9</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Line 7 begins a loop that is executed three times. It contains a nested inner loop.</li><br/>	<li>Line 8 stores the current value of <tt>sy-index</tt> from the outer loop.</li><br/>	<li>Line 9 begins the inner loop.</li><br/>	<li>On line 10, the number of the inner loop pass is multiplied by the number of the outer loop pass.</li><br/>	<li>Line 11 adds each row to the internal table.</li><br/>	<li>Line 13 begins a new line of output.</li><br/>	<li>Lines 14 through 16 write out the contents of the internal table.</li><br/>	<li>Line 17 deletes all rows from the internal table but does not free the memory. Refresh is used here instead of <tt>free</tt> because the outer loop repeats and refills the internal table again immediately.</li><br/>	<li>Line 20 deletes all rows and frees the memory for the internal table before the list is shown. This makes the program more efficient.</li><br/></ul><br/><h3><a name="UsingclearwithanInternalTable"></a>Using clear with an Internal Table</h3><br/>You can use the <tt>clear</tt> statement to do either of the following:<br/><ul><br/>	<li>Delete all rows from an internal table and leave the memory allocated.</li><br/>	<li>Clear the header line (set its components to blanks and zeros).</li><br/></ul><br/><h4>Syntax for the clear Statement When Used with an Internal Table</h4><br/>The following is the syntax for the <tt>clear</tt> statement when used with an internal table.<br/><blockquote><br/><pre>clear <i>it</i> | clear <i>it</i>[]</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is the name of an internal table.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>If <tt><i>it</i></tt> has a header line, <tt>clear it[]</tt> deletes all rows. <tt>clear it</tt> clears the header line.</li><br/>	<li>If <tt><i>it</i></tt> does not have a header line, both forms delete all rows and leave the memory allocated.</li><br/></ul><br/>The effect of <tt>clear</tt> on an internal table is summarized in Table 12.3. The effect of <tt>clear</tt> varies depending on whether the internal table has a header line or not.<br/><br/>Table 12.3  Effect of <tt>CLEAR</tt> on an Internal Table<br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="192"><center><b>Statement</b></center></td><br/><td width="192"><center><b>If it has a<br/>header line</b></center></td><br/><td width="192"><center><b>If it doesn't have<br/>a header line</b></center></td><br/></tr><br/><tr valign="top"><br/><td width="192"><tt>clear it</tt></td><br/><td width="192">Clears the header line</td><br/><td width="192">Deletes all rows</td><br/></tr><br/><tr valign="top"><br/><td width="192"><tt>clear it[]</tt></td><br/><td width="192">Deletes all rows</td><br/><td width="192">Deletes all rows</td><br/></tr><br/></tbody><br/></table><br/>The program in Listing 12.8 illustrates the use of the <tt>clear</tt> statement with an internal table.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.8 The clear Statement Can be Used to Clear the Header Line or Delete the Contents of an Internal Table<br/></b><br/><blockquote><br/><pre> 1  report ztx1208.<br/> 2  data: begin of it occurs 3,<br/> 3            f1,<br/> 4            end of it.<br/> 5 <br/> 6  it-f1 = 'X'.<br/> 7  append: it, it.<br/> 8 <br/> 9  clear it.         "it has a header line so clears the header line<br/>10 write: 'f1=', it-f1.<br/>11<br/>12 write: / ''.<br/>13 loop at it.<br/>14    write it-f1.<br/>15    endloop.<br/>16<br/>17 clear it[].       "same as: refresh it.<br/>18 loop at it.<br/>19    write it-f1.<br/>20    endloop.<br/>21 write: / 'sy-subrc=', sy-subrc.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.8 produces this output:<br/><blockquote><br/><pre>f1=            <br/>  X X          <br/>sy-subrc=     4</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Line 6 places <tt>'X'</tt> in the header line of <tt>it</tt>.</li><br/>	<li>Line 7 appends two rows to <tt>it</tt>; both have <tt>'X'</tt> in <tt>f1</tt>.</li><br/>	<li>Line 9 clears the header line for <tt>it</tt>.</li><br/>	<li>Line 10 writes blanks, showing that the header line for <tt>it</tt> is clear.</li><br/>	<li>Lines 13 through 15 produce output to show that the internal table still contains two rows.</li><br/>	<li>Line 17 clears the body of <tt>it</tt>, effectively deleting all rows and leaving the memory allocated. The contents of the header line are unchanged.</li><br/>	<li>Lines 18 through 20 do not produce any output because the internal table is empty.</li><br/>	<li>Line 21 shows the return code after the loop. This again confirms that no rows exist in the internal table.</li><br/></ul><br/><h3><a name="UsingthedeleteStatementtoDeleteRowsfromanInternalTable"></a>Using the delete Statement to Delete Rows from an Internal Table</h3><br/>Using the <tt>delete</tt> statement, you can delete one or more rows from an internal table.<br/><h4>Syntax for the delete Statement</h4><br/>The following is the syntax for the <tt>delete</tt> statement.<br/><blockquote><br/><pre>delete <i>it</i>  <i>(a)</i> [index <i>n</i>]<br/>           <i>(b)</i> [from <i>i</i>] [to <i>j</i>]<br/>           <i>(c)</i> [where <i>exp</i>]</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>n</i></tt>, <tt><i>fn</i></tt>, and <tt><i>tn</i></tt> are numeric literals, variables, or constants.</li><br/>	<li><tt><i>exp</i></tt> is a logical expression involving components of <tt><i>it</i></tt>.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>The additions following <tt><i>(a)</i></tt>,<i> </i><tt><i>(b)</i></tt>,<i> </i>and <tt><i>(c)</i></tt> are all optional.</li><br/>	<li>Only one of <tt><i>(a)</i></tt>,<i> </i><tt><i>(b)</i></tt>,<i> </i>or <tt><i>(c)</i></tt> can be specified.</li><br/>	<li><tt>delete it</tt> without any additions can only be used inside <tt>loop at it</tt>. In that case, it deletes the current row.</li><br/>	<li>If <tt>index <i>n</i></tt> is specified, the <i>n</i>th row of <tt><i>it</i></tt> is deleted.</li><br/>	<li>If <tt>from <i>i</i></tt> is specified, rows are deleted beginning with the <i>i</i>th row.</li><br/>	<li>If <tt>to <i>j</i></tt> is specified, rows are deleted up to and including the <i>j</i>th row.</li><br/>	<li>If <tt>from</tt> is not specified with <tt>to</tt>, <tt>from 1</tt> is assumed.</li><br/>	<li>If <tt>to</tt> is not specified with <tt>from</tt>, to the last row in the table is assumed.</li><br/>	<li>The expression <tt><i>exp</i></tt> must have a component of <tt><i>it</i></tt> on the left side of each comparison. For example, if <tt><i>it</i></tt> has components <tt><i>f1</i></tt> and <tt><i>f2</i></tt>, <tt><i>exp</i></tt> could be <tt>where f1 = 'A' and f2 = 'B'</tt>.</li><br/></ul><br/>Listing 12.9 shows a sample program that deletes data from an internal table using the <tt>delete</tt> statement.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.9  Deleting Rows from an Internal Table Can also be Done Using the delete Statement<br/></b><br/><blockquote><br/><pre>1  report ztx1209.<br/>2  data: begin of it occurs 12,<br/>3            f1,<br/>4            end of it,<br/> 5            alpha(12) value 'ABCDEFGHIJKL'.<br/> 6 <br/> 7  do 12 times varying it-f1 from alpha+0 next alpha+1.<br/> 8      append it.<br/> 9      enddo.<br/>10<br/>11 loop at it.<br/>12     write: / sy-tabix, it-f1.<br/>13     endloop.<br/>14<br/>15 delete it index 5.<br/>16 skip.<br/>17 loop at it.<br/>18     write: / sy-tabix, it-f1.<br/>19     endloop.<br/>20<br/>21 delete it from 6 to 8.<br/>22 skip.<br/>23 loop at it.<br/>24     write: / sy-tabix, it-f1.<br/>25     endloop.<br/>26<br/>27 delete it where f1 between 'B' and 'D'.<br/>28 skip.<br/>29 loop at it.<br/>30     write: / sy-tabix, it-f1.<br/>31     endloop.<br/>32<br/>33 loop at it where f1 between 'E' and 'J'.<br/>34     delete it.<br/>35     endloop.<br/>36<br/>37 skip.<br/>38 loop at it.<br/>39     write: / sy-tabix, it-f1.<br/>40     endloop.<br/>41<br/>42 read table it with key f1 = 'K' binary search.<br/>43 write: /, / 'sy-subrc=', sy-subrc, 'sy-tabix=', sy-tabix, / ''.<br/>44 if sy-subrc = 0.<br/>45     delete it index sy-tabix.<br/>46     endif.<br/>47<br/>48 skip.<br/>49 loop at it.<br/>50     write: / sy-tabix, it-f1.<br/>51     endloop.<br/>52<br/>53 free it.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.9 produces this output:<br/><blockquote><br/><pre>         1  A<br/>         2  B<br/>         3  C<br/>         4  D<br/>         5  E<br/>         6  F<br/>         7  G<br/>         8  H<br/>         9  I<br/>        10  J<br/>        11  K<br/>        12  L<br/><br/>         1  A<br/>         2  B<br/>         3  C<br/>         4  D<br/>         5  F<br/>         6  G<br/>         7  H<br/>         8  I<br/>         9  J<br/>        10  K<br/>        11  L<br/><br/>         1  A<br/>         2  B<br/>         3  C<br/>         4  D<br/>         5  F<br/>         6  J<br/>         7  K<br/>         8  L<br/><br/>         1  A<br/>         2  F<br/>         3  J<br/>         4  K<br/>         5  L<br/><br/>         1  A<br/>         2  K<br/>         3  L<br/><br/>sy-subrc=     0  sy-tabix=          2<br/><br/>         1  A<br/>         2  L</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 7 through 9 fill <tt>it</tt> with 12 rows containing the values <tt>'A'</tt> through <tt>'L'</tt>.</li><br/>	<li>Lines 11 through 13 write out the contents of the internal table.</li><br/>	<li>Line 15 deletes the fifth row, removing <tt>'E'</tt> from the table. The sixth row becomes the fifth, the seventh becomes the sixth, and so on.</li><br/>	<li>Line 21 deletes the sixth through eighth rows, removing <tt>G</tt>, <tt>H</tt>, and <tt>I</tt> from the table. The ninth row becomes the sixth, and so on.</li><br/>	<li>Line 27 deletes rows that have <tt>f1</tt> values between <tt>'B'</tt> and <tt>'D'</tt>, inclusive. This causes the second, third and fourth rows to be deleted.</li><br/>	<li>Line 33 retrieves rows having an <tt>f1</tt> value between <tt>'E'</tt> and <tt>'J'</tt>, inclusive. Rows 2 and 3 meet the criteria. The <tt>delete</tt> statement on line 34 doesn't have any additions, so it deletes the current row on each pass of the loop. This causes the second and third rows to be deleted.</li><br/>	<li>Line 42 locates the row having an <tt>f1</tt> value of <tt>'K'</tt>. Although <tt>it</tt> only contains three rows, <tt>binary search</tt> is included for the sake of good example. Row 2 matches, so <tt>sy-subrc</tt> is set to zero and <tt>sy-tabix</tt> is set to <tt>2</tt>.</li><br/>	<li>Line 45 is executed because <tt>sy-subrc</tt> is zero. It deletes row 2, removing <tt>'K'</tt> from the internal table.</li><br/></ul><br/>Like inserts, deletes inside of a <tt>loop at it</tt> do not affect the internal table immediately, but instead become effective on the next loop pass. When deleting a row <i>after</i> the current row, the table is re-indexed at the <tt>endloop</tt>, <tt>sy-tabix</tt> is incremented, and the next loop pass processes the row pointed to by <tt>sy-tabix</tt>. For example, suppose you are in the third loop pass and you delete row 4. When <tt>endloop</tt> is executed, the row is deleted, row 5 becomes row 4, and so on. <tt>sy-tabix</tt> is incremented by 1 and the next loop pass processes the next record.<br/><br/>If, when inside a loop, you delete a row <i>before</i> the current row, the table is again re-indexed at the <tt>endloop</tt>. This time, however, <tt>sy-tabix</tt> is incremented by 1 minus the number or rows deleted before the current row. The next time through the loop, the row following the current row is processed. Suppose, for example, in the third loop pass you delete row 3. At the <tt>endloop</tt>, row 4 becomes row 3, and so on. <tt>sy-tabix</tt> is incremented by 0, giving 3. Row 4 was re-indexed to 3, so it is processed on the next loop pass.<br/><h2><a name="CreatingTopListsUsingappendsortedby"></a><span style="color: #ff0000; font-size: x-large;">Creating Top 10 Lists Using append sorted by</span></h2><br/>Imagine that you are asked to create a report of the top 10 sales representatives in your company. Assuming you have a way of obtaining the total sales for each rep, you could do one of the following:<br/><ul><br/>	<li>Append all reps and their total sales into an internal table.</li><br/>	<li>Sort them descending by sales.</li><br/>	<li>Write out the first 10.</li><br/></ul><br/>This seems like a logical way to proceed. However, using the <tt>append sorted by</tt> statement often can produce the same result and be twice as efficient.<br/><h3><a name="SyntaxfortheappendsortedbyStatement"></a>Syntax for the append sorted by Statement</h3><br/>The following is the syntax for the <tt>append sorted by</tt> statement.<br/><blockquote><br/><pre>append [<i>wa</i> to] <i>it</i> sorted by <i>c</i>.</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt><i> </i>is the name of an internal table.</li><br/>	<li><tt><i>wa</i></tt> is a work area having the same structure as a row of the internal table.</li><br/>	<li><tt><i>c</i></tt> is a component of <tt><i>it</i></tt>.</li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>If <tt><i>wa</i> to</tt> is not specified, the row to be appended is taken from the header line.</li><br/>	<li>If <tt><i>wa</i> to</tt> is specified, the row to be appended is taken from the work area <tt><i>wa</i></tt>.</li><br/>	<li>Only one component <tt><i>c</i></tt> can be specified.</li><br/></ul><br/>The <tt>append sorted by</tt> statement takes a row from the work area and inserts it into the internal table at the point where it belongs in the sort order. It has two unusual properties:<br/><ul><br/>	<li>The number of rows that can be appended is limited by the value on the <tt>occurs</tt> clause. For example, if the <tt>occurs</tt> clause is 10, a maximum of 10 rows can be appended to the internal table. This is the only situation where <tt>occurs</tt> limits the number of rows that can be added to an internal table.</li><br/>	<li>It only sorts in descending order.</li><br/></ul><br/>The net effect is a "top <i>n</i> list," where <i>n</i> is the number on the <tt>occurs</tt> clause.<br/><br/>With each append, the system searches the existing table contents to determine where the new row fits. The sort order is by <tt><i>c</i></tt> descending. If there are fewer rows in the internal table than specified by <tt><i>n</i></tt> on the <tt>occurs</tt> clause, the row is as per the sort order. If there are <tt><i>n</i></tt> rows in the internal table, the row is inserted as per the sort order and the last row is discarded. If the value in <tt><i>c</i></tt> already exists in the internal table, the new row is always appended after existing rows that have the same value. Therefore, if <tt>occurs</tt> is 3 and row 3 contains <tt>'X'</tt> in <tt><i>c</i></tt>, a new row having <tt>'X'</tt> in <tt><i>c</i></tt> will not be appended.<br/><br/>Listing 12.10 shows a sample program that creates a list of the top three sales reps.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.10  Using append sorted by to Find the Top Three Sales Reps<br/></b><br/><blockquote><br/><pre> 1  report ztx1210.<br/> 2  data: begin of it occurs 3,<br/> 3            sales type p decimals 2,<br/> 4            name(10),<br/> 5            end of it.<br/> 6 <br/> 7  it-sales     = 100.<br/> 8  it-name      = 'Jack'.<br/> 9  append it sorted by sales.<br/>10<br/>11 it-sales     = 50.<br/>12 it-name      = 'Jim'.<br/>13 append it sorted by sales.<br/>14<br/>15 it-sales     = 150.<br/>16 it-name      = 'Jane'.<br/>17 append it sorted by sales.<br/>18<br/>19 it-sales     = 75.<br/>20 it-name      = 'George'.<br/>21 append it sorted by sales.<br/>22<br/>23 it-sales     = 200.<br/>24 it-name      = 'Gina'.<br/>25 append it sorted by sales.<br/>26<br/>27 it-sales     = 100.<br/>28 it-name      = 'Jeff'.<br/>29 append it sorted by sales.<br/>30<br/>31 loop at it.<br/>32     write: / it-sales, it-name.<br/>33     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.10 produces this output:<br/><blockquote><br/><pre>          200.00  Gina <br/>          150.00  Jane <br/>          100.00  Jack</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 2 through 5 define an internal table with an <tt>occurs</tt> value of <tt>3</tt>. If this internal table is filled using <tt>append sorted by</tt>, the maximum number of rows in this internal table will be limited to three.</li><br/>	<li>Lines 7 and 8 assign values to the header line.</li><br/>	<li>Line 9 searches <tt>it</tt> for the correct spot to insert the new row. The internal table is empty, so the row is simply appended (see Figure 12.1).<br/><a href="javascript:popUp('f12-1.gif')"><b>Figure 12.1 :</b> <i>No rows exist in the internal table, so the first row is simply appended</i>.</a></li><br/>	<li>50 comes after 100 when sorting sales descending, so line 13 inserts the new row after the existing one (see Figure 12.2).<br/><a href="javascript:popUp('f12-2.gif')"><b>Figure 12.2 :</b> <i>The second row is inserted in the correct sort sequence so that it comes after the first row</i>.</a></li><br/>	<li>150 comes before 100, so line 15 inserts the new row before the first row. The internal table now contains the maximum number of rows: three rows (see Figure 12.3).<br/><a href="javascript:popUp('f12-3.gif')"><b>Figure 12.3 :</b> <i>This time the sort sequence dictates that the new row be inserted before the first</i>.</a></li><br/>	<li>75 comes after 100, so line 21 inserts the new row after the second row, thereby making the new row the third row. The third row would become the fourth, but <tt>it</tt> can only hold three rows, so the fourth is discarded (see Figure 12.4).<br/><a href="javascript:popUp('f12-4.gif')"><b>Figure 12.4 :</b> <i>This row fits after the second, so it is inserted there. The internal table can hold a maximum of three rows, so the fourth row is discarded</i>.</a></li><br/>	<li>200 comes before 150, so line 25 inserts it before the first row. The rest of the rows are pushed down and the last is discarded (see Figure 12.5).<br/><a href="javascript:popUp('f12-5.gif')"><b>Figure 12.5 :</b> <i>This time the new row should come first. The existing rows are pushed down and the last one is discarded</i>.</a></li><br/>	<li>100 comes after 150, but there is already a 100 there. Line 29 therefore tries to insert the new row after the existing value of 100. That would make it row 4, so the row is not inserted at all (see Figure 12.6).<br/><a href="javascript:popUp('f12-6.gif')"><b>Figure 12.6 :</b> <i>This new row will follow all existing rows that have the same value. That would make it row 4, so it is not inserted</i>.</a></li><br/></ul><br/>Do not mix <tt>append sorted by</tt> with any other statements that add data to an internal table (such as <tt>insert</tt> or <tt>append</tt>). If you fill <tt>it</tt> with <tt>append sorted by</tt>, that should be the only statement you use. Mixing these statements will result in unpredictable behavior.<br/><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>TIP</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote><tt>append sorted by</tt> is more efficient when you are appending one row at a time to an internal table. If you already have the data in a database table and merely want to find the top 10 values, it is more efficient to insert the rows using an array operation and then sort. (For information on array operations, see Day 13, "Advanced Internal Tables: Part 2.")</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h2><a name="FillinganInternalTableUsingcollect"></a><span style="color: #ff0000; font-size: x-large;">Filling an Internal Table Using collect</span></h2><br/>Using the <tt>collect</tt> statement, you can create totals within an internal table as you fill it.<br/><h3><a name="SyntaxforthecollectStatement"></a>Syntax for the collect Statement</h3><br/>The following is the syntax for the <tt>collect</tt> statement.<br/><blockquote><br/><pre>collect [<i>wa</i> into] <i>it</i>.</pre><br/></blockquote><br/>where:<br/><ul><br/>	<li><tt><i>it</i></tt> is an internal table.</li><br/>	<li><tt><i>wa</i></tt> is a work area that has the same structure as <tt><i>it</i></tt><i>.</i></li><br/></ul><br/>The following points apply:<br/><ul><br/>	<li>If <tt><i>wa</i> into</tt> is specified, the row to be collected is taken from the explicit work area <tt><i>wa</i></tt>. In this case, the header line of the internal table is ignored, if it has one.</li><br/>	<li>If <tt><i>wa</i> into</tt> is not specified, the internal table must have a header line. The row to be collected is taken from the header line for <tt><i>it</i></tt>.</li><br/></ul><br/>When <tt>collect</tt> is executed, the system forms a key from the default key fields in the work area. The default key fields are the character fields (types <tt>c</tt>, <tt>n</tt>, <tt>d</tt>, <tt>t</tt>, and <tt>x</tt>). Therefore the key is composed of the values from all fields of type <tt>c</tt>, <tt>n</tt>, <tt>d</tt>, <tt>t</tt>, and <tt>x</tt>. It doesn't matter if they are beside one another or separated from each other by other fields.<br/><br/>The system then searches the body of the internal table for a row that has the same key as the key in the work area. If it doesn't find one, the row is appended to the end of the table. If it does find one, the numeric fields (types <tt>i</tt>, <tt>p</tt>, and <tt>f</tt>) in the work area are added to the corresponding fields in the found row. Listing 12.11 illustrates this concept.<br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/input.gif" /><br/><br/><hr /><br/><br/><b>Listing 12.11  collect Combines Rows as They Are Added to an Internal Table<br/></b><br/><blockquote><br/><pre>1  report ztx1211.<br/>2  data: begin of it occurs 10,<br/>3            date type d,                    "    part of default key<br/>4            tot_sales type p decimals 2,    "not part of default key<br/> 5            name(10),                       "    part of default key<br/> 6            num_sales type i value 1,       "not part of default key<br/> 7            end of it.<br/> 8 <br/> 9  it-date      = '19980101'.<br/>10 it-tot_sales  = 100.<br/>11 it-name       = 'Jack'.<br/>12 collect it.<br/>13<br/>14 it-date       = '19980101'.<br/>15 it-tot_sales  = 200.<br/>16 it-name       = 'Jim'.<br/>17 collect it.<br/>18<br/>19 it-date       = '19980101'.<br/>20 it-tot_sales  = 300.<br/>21 it-name       = 'Jack'.<br/>22 collect it.<br/>23<br/>24 it-date       = '19980101'.<br/>25 it-tot_sales  = 400.<br/>26 it-name       = 'Jack'.<br/>27 collect it.<br/>28<br/>29 it-date       = '19980101'.<br/>30 it-tot_sales  = 500.<br/>31 it-name       = 'Jim'.<br/>32 collect it.<br/>33<br/>34 it-date       = '19980101'.<br/>35 it-tot_sales  = 600.<br/>36 it-name       = 'Jane'.<br/>37 collect it.<br/>38<br/>39 it-date       = '19980102'.<br/>40 it-tot_sales  = 700.<br/>41 it-name       = 'Jack'.<br/>42 collect it.<br/>43<br/>44 loop at it.<br/>45     write: / it-date, it-tot_sales, it-name, it-num_sales.<br/>46     endloop.</pre><br/></blockquote><br/><br/><hr /><br/><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/output.gif" /><br/><br/>The code in Listing 12.11 produces this output:<br/><blockquote><br/><pre>19980101           800.00  Jack                3<br/>19980101           700.00  Jim                 2<br/>19980101           600.00  Jane                1<br/>19980102           700.00  Jack                1</pre><br/></blockquote><br/><img alt="" src="http://www.sapnet.ru/abap21day/button/analysis.gif" /><br/><ul><br/>	<li>Lines 2 through 7 define an internal table that has four components. Two are character types (<tt>date</tt> and <tt>name</tt>) and two are numeric types (<tt>tot_sales</tt> and <tt>num_sales</tt>). The default key is therefore composed of the components <tt>date</tt> and <tt>name</tt>.</li><br/>	<li>Lines 9 through 11 assign values to the header line components <tt>date</tt>, <tt>tot_sales</tt>, and <tt>name</tt>. <tt>num_sales</tt> still has a default value of <tt>1</tt>, assigned on line 6.</li><br/>	<li>Line 12 searches the body of <tt>it</tt> for a row that has the same values in <tt>date</tt> and <tt>name</tt> (the default key fields) as those in the header line. The internal table is empty, so no rows match. The header line is therefore appended to the internal table (see Figure 12.7).<br/><a href="javascript:popUp('f12-7.gif')"><b>Figure 12.7 :</b> <i>If the default key is not found in the body, the row is appended. The default key is composed of all non-numeric fields, so in this diagram it is the combination of date (first field) and name (third field)</i>.</a></li><br/>	<li>Line 17 behaves like line 12. The internal table has one row, but the values in the <tt>date</tt> and <tt>name</tt> fields don't match, so the header line is appended to the internal table (see Figure 12.8).<br/><a href="javascript:popUp('f12-8.gif')"><b>Figure 12.8 :</b> <i>Again, the default key is not found in the table, so this row is also appended</i>.</a></li><br/>	<li>Line 22 searches the internal table for a row that has <tt>'19980101'</tt> in the <tt>date</tt> field and <tt>'Jack'</tt> in the <tt>name</tt> field. Row 1 matches, so the numeric fields are added together. The header line <tt>tot_sales</tt> field contains <tt>200</tt>. This is added to the <tt>tot_sales</tt> field in row 1, yielding a total of <tt>300</tt>. The value in the <tt>num_sales</tt> field in the header line is also added to the <tt>num_sales</tt> field in row 1, giving a value of <tt>2</tt>. Row 1 is updated with these values. The contents of the header line are unchanged (see Figure 12.9).<br/><a href="javascript:popUp('f12-9.gif')"><b>Figure 12.9 :</b> <i>This time the default key matches the first row of the table. The numeric fields in the work area are added to the corresponding fields in the first row</i>.</a></li><br/>	<li>Line 27 searches for a row with a date of <tt>'19980101'</tt> and a name of <tt>'Jack'</tt>. Row 1 matches, so the contents of the numeric fields (<tt>tot_sales</tt> and <tt>num_sales</tt>) in the header line are added to the numeric fields in the found row (see Figure 12.10).<br/><a href="javascript:popUp('f12-10.gif')"><b>Figure 12.10:</b> <i>Again, the default key matches the first row of the table. The numeric fields in the work area are added to the corresponding fields in the first row</i>.</a></li><br/>	<li>Line 32 matches on row 2 and adds <tt>'500'</tt> to <tt>tot_sales</tt> and <tt>1</tt> to <tt>num_sales</tt> (see Figure 12.11).<br/><a href="javascript:popUp('f12-11.gif')"><b>Figure 12.11:</b> <i>This time the default key matches the second row of the table. The numeric fields in the work area are added to the corresponding fields in the second row</i>.</a></li><br/>	<li>On line 37, the values in <tt>date</tt> and <tt>name</tt> (the default key fields) of the header line do not match any rows in <tt>it</tt>, so a new row is appended to the end of the table (see Figure 12.12).<br/><a href="javascript:popUp('f12-12.gif')"><b>Figure 12.12:</b> <i>The default key does not match any rows this time, so a new row is appended</i>.</a></li><br/>	<li>Line 42 also causes a new row to be appended to the internal table because the values in <tt>date</tt> and <tt>name</tt> do not match in any rows of <tt>it</tt> (see Figure 12.13).<br/><a href="javascript:popUp('f12-13.gif')"><b>Figure 12.13:</b> <i>The default keys again do not match any rows, so another row is appended</i>.</a></li><br/></ul><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="600"><b>CAUTION</b></td><br/></tr><br/><tr valign="top"><br/><td width="600"><br/><blockquote>If you use <tt>collect </tt>to add rows to an internal table, all rows should be added using <tt>collect</tt>. You should not combine <tt>collect </tt>with <tt>append </tt>or any other statement that adds data to an internal table. The results will be unpredictable. The only other statement that you can use to modify the contents of an internal table filled via <tt>collect is modify ... transporting f1 f2 ..., </tt>where <tt>f1 </tt>and <tt>f2 </tt>are numeric fields only (non-default key fields).</blockquote><br/></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h2><a name="Summary"></a><span style="color: #ff0000; font-size: x-large;">Summary</span></h2><br/><ul><br/>	<li>The table body operator provides an efficient way to test for existence of data, to compare two internal tables for equality, or to duplicate an internal table.</li><br/>	<li>The <tt>describe table</tt> statement places the number of internal table rows into <tt>sy-tfill</tt>, the width of a row in bytes into <tt>sy-tleng</tt>, and the size of the <tt>occurs</tt> clause into <tt>sy-toccu</tt>.</li><br/>	<li>To copy a portion of an internal table from one to another, use <tt>append lines of</tt> or <tt>insert lines of</tt>.</li><br/>	<li><tt>editor-call</tt> displays the contents of an internal table in an editor. It enables the user to modify the data, and is also a useful debugging tool.</li><br/>	<li><tt>insert</tt> inserts a row at any position into an internal table. The position can be specified using an index or it can operate on the current row inside a loop.</li><br/>	<li><tt>modify</tt> modifies the contents of one or more rows. The row can be specified using an index or it can operate on the current row inside a loop. Using the <tt>where</tt> clause, you can modify the contents of many rows.</li><br/>	<li><tt>delete</tt> removes one or more rows. When used inside of a loop without additions, it deletes the current row. You can also specify a single index, an index range, or a <tt>where</tt> clause.</li><br/>	<li><tt>clear it</tt> clears the header line of <tt>it</tt>. If there is no header line, all rows are deleted. <tt>clear it[]</tt> always deletes all rows from <tt>it</tt>. The internal table memory remains allocated.</li><br/>	<li><tt>refresh</tt> always deletes all rows and leaves the memory allocated. It is exactly equivalent to <tt>clear it[]</tt>. It is used if the internal table will be refilled with data.</li><br/>	<li><tt>free it</tt> deletes all rows from <tt>it</tt> and frees the memory. It should be placed in the program immediately after internal table processing is complete.</li><br/>	<li>Use <tt>append sorted by</tt> to create top 10 lists instead of appending row by row and then sorting.</li><br/>	<li>Use <tt>collect</tt> to accumulate counts and totals within an internal table as it is being filled. It can also be used to ensure that all entries are unique.</li><br/></ul><br/>&nbsp;<br/><table border="1"><br/><tbody><br/><tr valign="top"><br/><td width="288"><center><b>DO</b></center></td><br/><td width="288"><center><b>DON'T</b></center></td><br/></tr><br/><tr valign="top"><br/><td width="288">DO use the free statement at the end of your program for all internal tables. This explicitly frees memory that will no longer be used while the user views the output.</td><br/><td width="288">DON'T append or insert lines one at a time if they can processed as a group using insert lines of or append lines of.</td><br/></tr><br/><tr valign="top"><br/><td width="288">DO use the table body operator to test for the existence of data.</td><br/><td width="288"></td><br/></tr><br/><tr valign="top"><br/><td width="288">DO use the append sorted by statement when creating top 10 lists, unless the list already exists and only needs to be sorted.</td><br/><td width="288"></td><br/></tr><br/></tbody><br/></table><br/>&nbsp;<br/><h2><a name="QampA"></a><span style="color: #ff0000; font-size: x-large;">Q&amp;A</span></h2><br/><table><br/><tbody><br/><tr valign="top"><br/><td width="48"><center><b>Q</b></center></td><br/><td><b>In this chapter you have covered so many ways to accomplish similar tasks. In ABAP/4 there always seems to be many ways to do the same thing. I'm just learning. I can only remember so many ways of doing something. Why not just show me the best way and forget the rest?</b></td><br/></tr><br/><tr valign="top"><br/><td width="48"><center><b>A</b></center></td><br/><td>I appreciate your concern. Wherever possible I leave out archaic, inefficient, rarely used, and duplicate methods. But there are two very good reasons for including the variations I have described here: 1) efficiency and 2) understanding of existing code. Due to the amount of data that resides in an R/3 system, efficiency is a primary concern in ABAP/4 programs. You should strive to use the most efficient form of each statement in a given situation. This can result in drastic performance improvements not only for your programs, but also for the entire system. It is common to have to rewrite code after it reaches production because it impacts system performance. As for the second point, programmers often spend more time reading existing code than creating new code, so you need to understand the subtle variations of these statements. They are used in abundance in SAP code. If you don't understand SAP's code, you won't be able to understand how the data got to its present state or how the output is arrived at.</td><br/></tr><br/></tbody><br/></table><br/><h2><a name="Workshop"></a><span style="color: #ff0000; font-size: x-large;">Workshop</span></h2><br/>The Workshop provides you two ways for you to affirm what you've learned in this chapter. The Quiz section poses questions to help you solidify your understanding of the material covered and the Exercise section provides you with experience in using what you have learned. You can find answers to the quiz questions and exercises in Appendix B, "Answers to Quiz Questions and Exercises."<br/><h3><a name="Quiz"></a>Quiz</h3><br/><ol><br/>	<li>If I modify the value of <tt>sy-tabix</tt> inside a loop, does this change the current row? For example, would the <tt>insert</tt>, <tt>modify</tt>, and <tt>delete</tt> statements operate on the row in the work area or the row indicated by <tt>sy-tabix</tt>?</li><br/>	<li>When would I use the value of <tt>sy-toccu</tt>? Why would I need to know the value of the <tt>occurs</tt> clause at runtime?</li><br/></ol><br/><h3><a name="Exercise"></a>Exercise 1</h3><br/>Read the contents of <tt>ztxlfa1</tt> into an internal table (use <tt>select</tt> <tt>into</tt> <tt>table</tt>). Then modify the <tt>land1</tt> column so that the third row contains 'US' (use <tt>modify</tt> <tt>transporting</tt> <tt>where</tt>). Also modify the regions, changing all MA to TX (use <tt>modify</tt> <tt>transporting</tt> <tt>where</tt>).
